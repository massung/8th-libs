\ -*- 8th -*-

ns: csv

private

\ field separator and current header
null var, sep
null var, header

public

-- w: csv:sep
-- s: s --
-- d: Set the current column separator.

: sep \ s --
    dup "(?<=^|%s)(?:\"(.*)\"|[^\"]*?)(?=%s|$)" strfmt r:new #p:sep ! ;

\ default to comma-separated values
"," sep

-- w: csv:next-line
-- s: f -- f s
-- d: Reads the next line of a csv, skipping comments.

: next-line \ f -- f s
    repeat f:getline null? if; 0 s:@ '# = while! ;

-- w: csv:next-row
-- s: f -- f a
-- d: Read the next line and parse it into an array.

: next-row \ f -- f a
    next-line null? if; #p:sep @ r:/ ;

-- w: csv:read-header
-- s: f -- f
-- d: Read the next row of the CSV and save it as the current header. If
-- d: there are no more rows then the header isn't read.

: read-header \ f -- f a
    next-row null; dup #p:header ! ;

-- w: csv:(col)
-- s: x -- n
-- d: Returns the column index of x, which may be an index or column name.

: (col) \ s -- n
    string? if #p:header @ swap ' s:= a:indexof nip then ;

-- w: csv:col
-- s: x -- w
-- d: Creates an anonymous word that will retrieve a column value from a row.
-- d: If x is a string, the column name is first looked up in the header,
-- d: otherwise it is assumed to be a column index.

: col \ x -- w
    (col) null? if ( ) else ' a:@ then curry ;

-- w: csv:col:
-- s: x <name> --
-- d: Just like csv:col, except that the column is defined as a word.

: col: \ x <name> -- \\\ IMMEDIATE
    (col) null? if ( ) else ' a:@ then curry: i;

-- w: csv:cut
-- s: a cols -- a1
-- d: Return an array of new values from an array of column words.

: cut \ a cols -- a1
    ' w:exec a:map nip ;

-- w: csv:.row
-- s: a s --
-- d: Print a row to standard out using the given separator.

: .row \ a s --
    swap a:len n:1- >r ( . r@ n:= if drop ;then dup . ) a:each cr drop rdrop ;

-- w: csv:each
-- s: f w -- f
-- d: Similar to a:each!. Every row in an opened CSV file (see csv:open)
-- d: is read and the word on the stack is called with the row.

: each \ f w -- f
    >r repeat next-row null? if r> 2drop ;then r@ w:exec again rdrop ;
