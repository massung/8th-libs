\ -*- 8th -*-

ns: csv

private

\ open csv properties
null var, (cols)
null var, (header)

\ each, map, etc...
defer: (proc)

public

-- w: csv:>sep
-- s: s --
-- d: Set the current column separator.

: >sep \ s --
    dup "(?<=^|%s)(?:\"(.*)\"|[^\"]*?)(?=%s|$)" strfmt r:new #p:(cols) ! ;

\ default to a comma-separated table
"," >sep

-- w: csv:>header
-- s: s --
-- d: Parse TOS as a record and make it the current header row.

: >header \ a --
    #p:(header) ! ;

-- w: csv:next
-- s: f -- f s | f null
-- d: Reads the next line of a csv, skipping comments.

: next \ f -- f s | f null
    repeat f:getline null? if; 0 s:@ '# = while! ;

-- w: csv:rec>
-- s: s -- a
-- d: Take a CSV record string and convert it into an array of column values.

: rec> \ f -- f a
    next null? if; #p:(cols) @ r:/ ;

-- w: csv:.rec
-- s: a s -- a
-- d: Print a record to standard out using the given separator.

: .rec \ a s -- a
    swap a:len n:1- >r ( . r@ n:= if drop ;then dup . ) a:each cr ;

-- w: csv:col
-- s: a x -- s
-- d: Looks up a column by name if @x@ is a string, otherwise assumes @x@ is
-- d: a column index and returns the column value at that index.

: col \ x -- ix
    number? if; #p:(header) @ swap ' s:= a:indexof nip ;

-- w: csv:cut
-- s: a cols -- a1
-- d: Select columns from a record with an arrow of column index or name.

: cut \ a cols -- a1
    ( string? if col then a:@ ) a:map nip ;

-- w: csv:test
-- s: a col n w -- a n1
-- d: Return the sigma (-1, 0, 1) of a column compared against a constant.

: cmp \ a col n -- a n1
    >r col a:@ >n r> n:cmp ;

-- w: csv:each
-- s: f w -- f
-- d: Similar to a:each!. Every row in an opened CSV file (see csv:open)
-- d: is read and the word on the stack is called with the record.

: each \ f w -- f
    w:is #p:(proc) repeat
        rec> null; #p:(proc)
    again ;
